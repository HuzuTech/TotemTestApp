;(function(e,t,n){function i(n,s){if(!t[n]){if(!e[n]){var o=typeof require=="function"&&require;if(!s&&o)return o(n,!0);if(r)return r(n,!0);throw new Error("Cannot find module '"+n+"'")}var u=t[n]={exports:{}};e[n][0].call(u.exports,function(t){var r=e[n][1][t];return i(r?r:t)},u,u.exports)}return t[n].exports}var r=typeof require=="function"&&require;for(var s=0;s<n.length;s++)i(n[s]);return i})({1:[function(require,module,exports){
Totem = require('../totem');

},{"../totem":2}],3:[function(require,module,exports){
// Generated by CoffeeScript 1.6.1
(function() {
  var User;

  User = (function() {

    function User(client, attributes) {
      this.client = client;
      this.setAttributes(attributes);
    }

    User.prototype.goods = function() {
      var d,
        _this = this;
      d = $.Deferred();
      this.client.get("/users/" + this.attributes.Id + "/goods", function(err, goods) {
        if (err) {
          return d.reject(err);
        }
        return d.resolve(goods);
      });
      return d.promise();
    };

    User.prototype.avatars = function() {
      var d,
        _this = this;
      d = $.Deferred();
      this.client.get("/users/" + this.attributes.Id + "/avatars?include=tree", function(err, avatars) {
        if (err) {
          return d.reject(err);
        }
        return d.resolve(avatars);
      });
      return d.promise();
    };

    User.prototype.assets = function() {
      var d, tree,
        _this = this;
      d = $.Deferred();
      tree = {};
      this.goods().then(function(goods) {
        var good, _i, _len;
        for (_i = 0, _len = goods.length; _i < _len; _i++) {
          good = goods[_i];
          tree[good.Label] = [];
        }
        return tree;
      }).then(function(tree) {
        return _this.assetsForGoods(tree);
      }).then(function(assets) {
        return d.resolve(assets);
      });
      return d.promise();
    };

    User.prototype.assetsForGoods = function(tree) {
      var d, good, tasks, _fn,
        _this = this;
      d = $.Deferred();
      tasks = [];
      _fn = function(good) {
        return tasks.push((function() {
          var td;
          td = $.Deferred();
          _this.assetsForGood(good).then(function(assets) {
            tree[good] = assets;
            return td.resolve();
          });
          return td.promise();
        })());
      };
      for (good in tree) {
        _fn(good);
      }
      $.when.apply($, tasks).done(function() {
        return d.resolve(tree);
      });
      return d.promise();
    };

    User.prototype.assetsForGood = function(good) {
      var d,
        _this = this;
      d = $.Deferred();
      this.client.get("/goods/" + good + "/assets?include=tree", function(err, assets) {
        if (err) {
          return d.reject(err);
        }
        return d.resolve(assets);
      });
      return d.promise();
    };

    User.prototype.setAttributes = function(attributes) {
      var key, value, _ref, _results;
      if ((_ref = this.attributes) == null) {
        this.attributes = {};
      }
      _results = [];
      for (key in attributes) {
        value = attributes[key];
        _results.push(this.attributes[key] = value);
      }
      return _results;
    };

    return User;

  })();

  if (typeof module !== "undefined" && module !== null) {
    module.exports = User;
  }

}).call(this);

},{}],4:[function(require,module,exports){
// Generated by CoffeeScript 1.6.1
(function() {
  var Avatar;

  Avatar = (function() {

    function Avatar(client, attributes) {
      this.client = client;
      this.setAttributes(attributes);
    }

    Avatar.prototype.build = function(ensemble) {
      var asset, category, _results;
      this._ensemble = {};
      _results = [];
      for (category in ensemble) {
        asset = ensemble[category];
        _results.push(this._ensemble[category] = asset);
      }
      return _results;
    };

    Avatar.prototype.equip = function(category, asset) {
      if (this.ensemble()[category] == null) {
        throw new Error("No such category: " + category);
      }
      if (asset != null) {
        this.ensemble()[category] = asset;
      }
      return this.ensemble()[category];
    };

    Avatar.prototype.equipped = function(category) {
      return this.equip(category);
    };

    Avatar.prototype.ensemble = function() {
      return this._ensemble;
    };

    Avatar.prototype.colour1 = function(colour, category) {
      return this.setColour(colour, 1, category);
    };

    Avatar.prototype.colour2 = function(colour, category) {
      return this.setColour(colour, 2, category);
    };

    Avatar.prototype.save = function() {
      var d, key, payload, prelude, value, _ref, _ref1,
        _this = this;
      d = $.Deferred();
      payload = {};
      _ref = this.attributes;
      for (key in _ref) {
        value = _ref[key];
        payload[key] = value;
      }
      if ((_ref1 = payload.Label) == null) {
        payload.Label = this.randomLabel();
      }
      prelude = payload.Id != null ? "update" : "create";
      this[prelude](payload).then(function() {
        return _this.saveAssets();
      }).then(function() {
        return d.resolve();
      });
      return d.promise();
    };

    Avatar.prototype.setColour = function(colour, position, category) {
      if (category != null) {
        return this.setColourOnCategory(colour, position, category);
      } else {
        return this.setColourGlobal(colour, position);
      }
    };

    Avatar.prototype.setColourOnCategory = function(colour, position, category) {
      var attribute;
      attribute = "Colour" + position;
      return this.equipped(category)[attribute] = colour;
    };

    Avatar.prototype.setColourGlobal = function(colour, position) {
      var category, _results;
      _results = [];
      for (category in this.ensemble()) {
        _results.push(this.setColourOnCategory(colour, position, category));
      }
      return _results;
    };

    Avatar.prototype.setAttributes = function(attributes) {
      var key, value, _ref, _results;
      if ((_ref = this.attributes) == null) {
        this.attributes = {};
      }
      _results = [];
      for (key in attributes) {
        value = attributes[key];
        _results.push(this.attributes[key] = value);
      }
      return _results;
    };

    Avatar.prototype.randomLabel = function() {
      return "hapi-avatar-" + (Math.random() * 1e18).toString(16);
    };

    Avatar.prototype.saveAssets = function() {
      var d, payload, url;
      d = $.Deferred();
      url = "/avatars/" + this.attributes.Id + "/assets";
      payload = this.buildAssetPayload();
      this.client.post(url, payload, function(err) {
        if (err) {
          throw err;
        }
        return d.resolve();
      });
      return d.promise();
    };

    Avatar.prototype.buildAssetPayload = function() {
      var asset, category, payload, _ref;
      payload = [];
      _ref = this.ensemble();
      for (category in _ref) {
        asset = _ref[category];
        payload.push({
          AssetId: asset.Id,
          Colour1: asset.Colour1,
          Colour2: asset.Colour2
        });
      }
      return payload;
    };

    Avatar.prototype.create = function(payload) {
      var d, url,
        _this = this;
      d = $.Deferred();
      url = "/users/" + this.attributes.User + "/avatars";
      this.client.post(url, payload, function(err, response) {
        if (err) {
          throw err;
        }
        _this.setAttributes(response);
        return d.resolve();
      });
      return d.promise();
    };

    Avatar.prototype.update = function(payload) {
      var d, url,
        _this = this;
      d = $.Deferred();
      url = "/avatars/" + payload.Id;
      this.client.put(url, payload, function(err, response) {
        if (err) {
          throw err;
        }
        _this.setAttributes(response);
        return d.resolve();
      });
      return d.promise();
    };

    return Avatar;

  })();

  if (typeof module !== "undefined" && module !== null) {
    module.exports = Avatar;
  }

}).call(this);

},{}],5:[function(require,module,exports){
// Generated by CoffeeScript 1.6.1
(function() {
  var Compositor;

  Compositor = (function() {

    function Compositor() {}

    Compositor.prototype.prepare = function(ensemble, categories) {
      var category, categoryStack, composite, _i, _len;
      composite = [];
      for (_i = 0, _len = categories.length; _i < _len; _i++) {
        category = categories[_i];
        categoryStack = {};
        if (ensemble[category] != null) {
          categoryStack[category] = this.prepareStack(ensemble[category]);
          composite.push(categoryStack);
        }
      }
      return composite;
    };

    Compositor.prototype.prepareStack = function(asset) {
      var layer, stack, _i, _len, _ref;
      stack = [];
      _ref = asset.Layers;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        layer = _ref[_i];
        stack.push(this.prepareCell(layer, [asset.Colour1, asset.Colour2]));
      }
      return stack;
    };

    Compositor.prototype.prepareCell = function(layer, colours) {
      var cell, colour;
      cell = {
        image: layer.Uri,
        colour: null
      };
      if ((layer.Colour != null) > 0 && (colour = colours[layer.Colour - 1])) {
        cell.colour = colour;
      }
      return cell;
    };

    Compositor.prototype.clearCanvas = function(canvas) {
      var context;
      context = canvas.getContext("2d");
      return context.clearRect(0, 0, canvas.width, canvas.height);
    };

    Compositor.prototype.drawOn = function(ensemble, categories, canvas) {
      var category, composite, name, stack, tasks, _fn, _i, _len,
        _this = this;
      composite = this.prepare(ensemble, categories);
      tasks = [];
      for (_i = 0, _len = composite.length; _i < _len; _i++) {
        category = composite[_i];
        _fn = function(stack) {
          return tasks.push(function() {
            return _this.drawStackOn(stack, canvas);
          });
        };
        for (name in category) {
          stack = category[name];
          _fn(stack);
        }
      }
      this.clearCanvas(canvas);
      return this.sequence(tasks);
    };

    Compositor.prototype.drawCellOn = function(cell, canvas) {
      var d,
        _this = this;
      d = $.Deferred();
      this.loadImage(cell.image).then(function(image) {
        var colour;
        if ((colour = cell.colour)) {
          console.log(colour);
          image = _this.colourise(image, colour, canvas);
        }
        canvas.getContext("2d").drawImage(image, 0, 0);
        return d.resolve();
      });
      return d.promise();
    };

    Compositor.prototype.drawStackOn = function(stack, canvas) {
      var cell, tasks, _fn, _i, _len,
        _this = this;
      tasks = [];
      _fn = function(cell) {
        return tasks.push(function() {
          return _this.drawCellOn(cell, canvas);
        });
      };
      for (_i = 0, _len = stack.length; _i < _len; _i++) {
        cell = stack[_i];
        _fn(cell);
      }
      return this.sequence(tasks);
    };

    Compositor.prototype.sequence = function(tasks) {
      var i, seq, task, _i, _len, _ref;
      seq = typeof tasks[0] === "function" ? tasks[0]() : void 0;
      if (tasks[1] == null) {
        return seq;
      }
      _ref = tasks.slice(1);
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        task = _ref[i];
        seq = (function(i) {
          return seq.then(function() {
            return tasks[i + 1]();
          });
        })(i);
      }
      return seq;
    };

    Compositor.prototype.colourise = function(image, colour, canvas) {
      var colourisingCanvas, context;
      colourisingCanvas = this.getColourisingCanvas(colour, canvas);
      context = colourisingCanvas.getContext("2d");
      context.drawImage(image, 0, 0);
      return colourisingCanvas;
    };

    Compositor.prototype.getColourisingCanvas = function(colour, canvas) {
      var context, dupCanvas;
      dupCanvas = this.duplicateCanvas(canvas);
      context = dupCanvas.getContext("2d");
      context.fillStyle = colour;
      context.fillRect(0, 0, dupCanvas.width, dupCanvas.height);
      context.globalCompositeOperation = "destination-in";
      return dupCanvas;
    };

    Compositor.prototype.duplicateCanvas = function(canvas) {
      var dupCanvas;
      dupCanvas = document.createElement("canvas");
      dupCanvas.width = canvas.width;
      dupCanvas.height = canvas.height;
      return dupCanvas;
    };

    Compositor.prototype.loadImage = function(image) {
      var d, imageElement;
      d = $.Deferred();
      if (image instanceof HTMLImageElement) {
        if (this.imageComplete(image)) {
          d.resolve(image);
        } else {
          image.onload = function() {
            return d.resolve(image);
          };
        }
      } else {
        imageElement = new Image;
        imageElement.onload = function() {
          return d.resolve(imageElement);
        };
        imageElement.src = image;
      }
      return d.promise();
    };

    Compositor.prototype.imageComplete = function(image) {
      return image.complete || image.width + image.height > 0;
    };

    return Compositor;

  })();

  if (typeof module !== "undefined" && module !== null) {
    module.exports = Compositor;
  }

}).call(this);

},{}],6:[function(require,module,exports){
// Generated by CoffeeScript 1.6.1
(function() {
  var Inventory;

  Inventory = (function() {

    function Inventory(goods, categories, assets) {
      this.goods = goods;
      this.categories = categories;
      this.assets = assets;
    }

    Inventory.prototype.representation = function(_representation) {
      this._representation = _representation;
    };

    Inventory.prototype.good = function(_good) {
      this._good = _good;
    };

    Inventory.prototype.category = function(_category) {
      this._category = _category;
    };

    Inventory.prototype.get = function(options) {
      var tree;
      if (options == null) {
        options = {};
      }
      options = this.checkGetOptions(options);
      tree = $.extend(true, {}, this.assets);
      tree = this.scopeByRepresentation(tree, options.representation);
      tree = this.categoriseAssets(tree);
      if (options.category != null) {
        tree = this.scopeByCategory(tree, options.category);
      }
      if (options.good != null) {
        tree = this.scopeByGood(tree, options.good);
      } else {
        tree = this.unpackFromGoods(tree, options.category == null);
      }
      return tree;
    };

    Inventory.prototype.randomEnsemble = function(options) {
      var assets, c, categories, category, ensemble, inventory, _i, _len;
      ensemble = {};
      inventory = this.get(options);
      categories = (function() {
        var _i, _len, _ref, _results;
        _ref = this.categories;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          c = _ref[_i];
          _results.push(c.Label);
        }
        return _results;
      }).call(this);
      for (_i = 0, _len = categories.length; _i < _len; _i++) {
        category = categories[_i];
        if ((assets = inventory[category])) {
          ensemble[category] = this.random(assets);
        }
      }
      return ensemble;
    };

    Inventory.prototype.avatarEnsemble = function(assets, representation) {
      var asset, categoriesById, category, completeAsset, ensemble, _i, _len;
      ensemble = {};
      categoriesById = this.byId(this.categories);
      for (_i = 0, _len = assets.length; _i < _len; _i++) {
        asset = assets[_i];
        completeAsset = this.findAsset(asset.AssetId);
        category = categoriesById[completeAsset.CategoryId];
        completeAsset = this.collapseAssetRepresentation(completeAsset, representation);
        completeAsset.Colour1 = asset.Colour1;
        completeAsset.Colour2 = asset.Colour2;
        ensemble[category] = completeAsset;
      }
      return ensemble;
    };

    Inventory.prototype.findAsset = function(assetId) {
      var asset, assets, good, _i, _len, _ref;
      _ref = this.assets;
      for (good in _ref) {
        assets = _ref[good];
        for (_i = 0, _len = assets.length; _i < _len; _i++) {
          asset = assets[_i];
          if (String(asset.Id) === String(assetId)) {
            return asset;
          }
        }
      }
    };

    Inventory.prototype.checkGetOptions = function(options) {
      var _ref, _ref1, _ref2;
      if ((_ref = options.representation) == null) {
        options.representation = this._representation;
      }
      if ((_ref1 = options.category) == null) {
        options.category = this._category;
      }
      if ((_ref2 = options.good) == null) {
        options.good = this._good;
      }
      if (options.representation == null) {
        throw new Error("You must set options.representation when calling\nInventory::get.");
      }
      if (!this.validate(this.categories, options.category)) {
        throw new Error("Inventory::get: '" + category + "' is not a valid category.");
      }
      if (!this.validate(this.goods, options.good)) {
        throw new Error("Inventory::get: '" + good + "' is not a valid good.");
      }
      return options;
    };

    Inventory.prototype.validate = function(collection, option) {
      var e, _i, _len;
      if (option == null) {
        return true;
      }
      for (_i = 0, _len = collection.length; _i < _len; _i++) {
        e = collection[_i];
        if (e.Label === option) {
          return true;
        }
      }
      return false;
    };

    Inventory.prototype.scopeByRepresentation = function(tree, representation) {
      var asset, assets, good, i, _i, _len;
      tree = $.extend(true, {}, tree);
      for (good in tree) {
        assets = tree[good];
        for (i = _i = 0, _len = assets.length; _i < _len; i = ++_i) {
          asset = assets[i];
          assets[i] = this.collapseAssetRepresentation(asset, representation);
        }
      }
      return tree;
    };

    Inventory.prototype.collapseAssetRepresentation = function(asset, representation) {
      var collapsedAsset, r, _i, _len, _ref;
      collapsedAsset = $.extend(true, {}, asset);
      _ref = collapsedAsset.Representations;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        r = _ref[_i];
        if (!(r.Label === representation)) {
          continue;
        }
        collapsedAsset.Thumbnail = r.Thumbnail;
        collapsedAsset.Layers = r.Layers.slice(0);
      }
      delete collapsedAsset.Representations;
      return collapsedAsset;
    };

    Inventory.prototype.scopeByCategory = function(tree, category) {
      var assets, good, inCategory;
      tree = $.extend(true, {}, tree);
      for (good in tree) {
        assets = tree[good];
        inCategory = assets[category];
        tree[good] = inCategory;
      }
      return tree;
    };

    Inventory.prototype.scopeByGood = function(tree, good) {
      tree = $.extend(true, {}, tree);
      return tree = tree[good];
    };

    Inventory.prototype.categoriseAssets = function(tree) {
      var asset, assets, categories, categorised, categoryLabel, good, _i, _len, _ref;
      tree = $.extend(true, {}, tree);
      categories = this.byId(this.categories);
      for (good in tree) {
        assets = tree[good];
        categorised = {};
        for (_i = 0, _len = assets.length; _i < _len; _i++) {
          asset = assets[_i];
          categoryLabel = categories[asset.CategoryId];
          if ((_ref = categorised[categoryLabel]) == null) {
            categorised[categoryLabel] = [];
          }
          categorised[categoryLabel].push(asset);
        }
        tree[good] = categorised;
      }
      return tree;
    };

    Inventory.prototype.unpackFromGoods = function(tree, categorised) {
      var assets, category, contents, good, unpacked, _ref;
      tree = $.extend(true, {}, tree);
      unpacked = categorised ? {} : [];
      for (good in tree) {
        contents = tree[good];
        if (!categorised) {
          unpacked = unpacked.concat(contents);
        } else {
          for (category in contents) {
            assets = contents[category];
            if ((_ref = unpacked[category]) == null) {
              unpacked[category] = [];
            }
            unpacked[category] = unpacked[category].concat(assets);
          }
        }
      }
      return unpacked;
    };

    Inventory.prototype.byId = function(ary) {
      var byId, o, _i, _len;
      byId = {};
      for (_i = 0, _len = ary.length; _i < _len; _i++) {
        o = ary[_i];
        byId[o.Id] = o.Label;
      }
      return byId;
    };

    Inventory.prototype.random = function(ary) {
      var idx;
      idx = Math.floor(Math.random() * ary.length);
      return ary[idx];
    };

    return Inventory;

  })();

  if (typeof module !== "undefined" && module !== null) {
    module.exports = Inventory;
  }

}).call(this);

},{}],2:[function(require,module,exports){
// Generated by CoffeeScript 1.6.1
(function() {
  var Avatar, Compositor, Inventory, Totem, User, hapilib;

  hapilib = require("hapilib/lib/solo/index");

  User = require("./user");

  Avatar = require("./avatar");

  Compositor = require("./compositor");

  Inventory = require("./inventory");

  Totem = (function() {

    function Totem(params) {
      if (params != null) {
        hapilib.init(params);
      }
      this.client = hapilib.restClient;
      this.cache = {};
    }

    Totem.prototype.autoLogin = function(cb) {
      return hapilib.autoLogin(cb);
    };

    Totem.prototype.exchangeCode = function(code, cb) {
      return hapilib.serverExchangeCode(code, cb);
    };

    Totem.prototype.user = function() {
      var _ref;
      if (!hapilib.user) {
        throw new Error("No user is active.");
      }
      return (_ref = this._user) != null ? _ref : this._user = new User(this.client, hapilib.user);
    };

    Totem.prototype.categories = function() {
      var d,
        _this = this;
      d = $.Deferred();
      if (this.cache.categories) {
        return d.resolve(this.cache.categories);
      }
      this.client.get("/categories", function(err, res) {
        var categories;
        if (err) {
          return d.reject(err);
        }
        categories = _this.sortCategories(res);
        _this.cache.categories = categories;
        return d.resolve(categories);
      });
      return d.promise();
    };

    Totem.prototype.representation = function(_representation) {
      this._representation = _representation;
    };

    Totem.prototype.goods = function() {
      return this.user().goods();
    };

    Totem.prototype.assets = function() {
      return this.user().assets();
    };

    Totem.prototype.inventory = function(representation) {
      var assets, categories, d, getAssets, getCategories, getGoods, goods, tasks, _ref,
        _this = this;
      if (representation == null) {
        representation = this._representation;
      }
      d = $.Deferred();
      if (this.cache.inventory) {
        this.cache.inventory.representation(representation);
        return d.resolve(this.cache.inventory);
      }
      _ref = [null, null, null], goods = _ref[0], categories = _ref[1], assets = _ref[2];
      getCategories = (function() {
        return _this.categories().then(function(c) {
          return categories = c;
        });
      })();
      getAssets = (function() {
        return _this.assets().then(function(a) {
          return assets = a;
        });
      })();
      getGoods = (function() {
        return _this.goods().then(function(g) {
          return goods = g;
        });
      })();
      tasks = [getCategories, getAssets, getGoods];
      $.when.apply($, tasks).then(function() {
        var inventory;
        inventory = new Inventory(goods, categories, assets);
        inventory.representation(representation);
        _this.cache.inventory = inventory;
        return d.resolve(inventory);
      });
      return d.promise();
    };

    Totem.prototype.avatar = function(attributes) {
      if (attributes == null) {
        attributes = {};
      }
      attributes.User = this.user().attributes.Id;
      return new Avatar(this.client, attributes);
    };

    Totem.prototype.avatars = function(representation) {
      var avatars, categories, d, inventory,
        _this = this;
      if (representation == null) {
        representation = this._representation;
      }
      d = $.Deferred();
      categories = null;
      inventory = null;
      avatars = [];
      this.inventory().then(function(inv) {
        return inventory = inv;
      }).then(function() {
        return _this.user().avatars();
      }).then(function(avs) {
        var attrs, _i, _len;
        for (_i = 0, _len = avs.length; _i < _len; _i++) {
          attrs = avs[_i];
          avatars.push(_this.buildAvatar(attrs, inventory, representation));
        }
        return d.resolve(avatars);
      });
      return d.promise();
    };

    Totem.prototype.buildAvatar = function(attributes, inventory, representation) {
      var avatar, ensemble;
      if (representation == null) {
        representation = this._representation;
      }
      ensemble = inventory.avatarEnsemble(attributes.Assets, representation);
      delete attributes.Assets;
      avatar = new Avatar(this.client, attributes);
      avatar.build(ensemble);
      return avatar;
    };

    Totem.prototype.randomise = function(avatar, representation) {
      var d;
      if (representation == null) {
        representation = this._representation;
      }
      d = $.Deferred();
      this.inventory().then(function(inventory) {
        var ensemble;
        ensemble = inventory.randomEnsemble({
          representation: representation
        });
        avatar.build(ensemble);
        return d.resolve();
      });
      return d.promise();
    };

    Totem.prototype.drawOn = function(avatar, canvas) {
      var d,
        _this = this;
      d = $.Deferred();
      this.categories().then(function(categories) {
        var c, categoryNames;
        categoryNames = (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = categories.length; _i < _len; _i++) {
            c = categories[_i];
            _results.push(c.Label);
          }
          return _results;
        })();
        return _this.compositor().drawOn(avatar.ensemble(), categoryNames, canvas).then(function() {
          return d.resolve();
        });
      });
      return d.promise();
    };

    Totem.prototype.byId = function(ary) {
      var byId, o, _i, _len;
      byId = {};
      for (_i = 0, _len = ary.length; _i < _len; _i++) {
        o = ary[_i];
        byId[o.Id] = o.Label;
      }
      return byId;
    };

    Totem.prototype.compositor = function() {
      var _ref;
      return (_ref = this._compositor) != null ? _ref : this._compositor = new Compositor;
    };

    Totem.prototype.sortCategories = function(categories) {
      return categories.sort(function(a, b) {
        return a.SortOrder - b.SortOrder;
      });
    };

    return Totem;

  })();

  if (typeof module !== "undefined" && module !== null) {
    module.exports = Totem;
  }

}).call(this);

},{"./user":3,"./compositor":5,"./avatar":4,"./inventory":6,"hapilib/lib/solo/index":7}],7:[function(require,module,exports){
module.exports = require('../com/huzutech/hapi/HAPI').Singleton;

},{"../com/huzutech/hapi/HAPI":8}],8:[function(require,module,exports){
// Generated by CoffeeScript 1.6.1
(function() {
  var HAPI, HAPIExchangeCode, HAPIFacebook, HAPIJQuery, HAPIModule, HAPIRest, TokenManager, exportObj,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  HAPIModule = require("./objects/HAPIModule");

  HAPIExchangeCode = require("./HAPIExchangeCode");

  HAPIFacebook = require("./HAPIFacebook");

  HAPIRest = require("./rest/HAPIRest");

  HAPIJQuery = require("./rest/HAPIJQuery");

  TokenManager = require("./rest/TokenManager");

  HAPI = (function(_super) {

    __extends(HAPI, _super);

    HAPI.include(HAPIFacebook);

    HAPI.include(HAPIExchangeCode);

    function HAPI(restClient) {
      this.restClient = restClient;
      if (!((this.restClient != null) && this.restClient instanceof HAPIRest)) {
        throw new TypeError("You need to pass an implementation of HAPIRest");
      }
      this.tokenManager = new TokenManager(this.restClient);
    }

    HAPI.prototype.init = function(params) {
      this.endPoint = params.endPoint;
      this.clientId = params.clientId;
      return this.restClient.setBaseUrl(this.endPoint);
    };

    HAPI.prototype.autoLogin = function(callback) {
      var storedToken,
        _this = this;
      if ((typeof localStorage !== "undefined" && localStorage !== null ? localStorage.getItem("HAPIToken") : void 0) != null) {
        storedToken = localStorage.getItem("HAPIToken");
        return this.restClient.get("/tokens/" + (encodeURIComponent(storedToken)), function(err, data) {
          if ((err != null) || (data != null ? data.expiresIn : void 0) === 0) {
            _this.removeStoredToken();
            return callback(new Error("Stored TokenManager has expired"));
          } else {
            return _this.completeLoginProcess(storedToken, data.expiresIn, callback);
          }
        });
      } else {
        return callback(new Error("Not logged in"));
      }
    };

    HAPI.prototype.logout = function() {
      this.removeStoredToken();
      this.tokenManager.removeToken();
      return this.user = void 0;
    };

    HAPI.prototype.onSessionExpired = function(onSessionExpiredCallback) {
      this.onSessionExpiredCallback = onSessionExpiredCallback;
      return this.tokenManager.onTokenExpired(this.onSessionExpiredCallback);
    };

    HAPI.prototype.completeLoginProcess = function(accessToken, expiresIn, callback) {
      var _this = this;
      this.tokenManager.setToken(accessToken, expiresIn);
      if (typeof localStorage !== "undefined" && localStorage !== null) {
        localStorage.setItem("HAPIToken", accessToken);
      }
      return this.restClient.get("/me", function(err, data) {
        if (data) {
          _this.user = data;
        }
        return callback(err);
      });
    };

    HAPI.prototype.removeStoredToken = function() {
      if ((typeof localStorage !== "undefined" && localStorage !== null ? localStorage.getItem("HAPIToken") : void 0) != null) {
        return localStorage.removeItem("HAPIToken");
      }
    };

    return HAPI;

  })(HAPIModule);

  exportObj = {
    Singleton: new HAPI(new HAPIJQuery()),
    HAPI: HAPI
  };

  if (typeof module !== "undefined" && module !== null) {
    module.exports = exportObj;
  }

}).call(this);

},{"./objects/HAPIModule":9,"./HAPIExchangeCode":10,"./HAPIFacebook":11,"./rest/HAPIJQuery":12,"./rest/HAPIRest":13,"./rest/TokenManager":14}],9:[function(require,module,exports){
// Generated by CoffeeScript 1.6.1
(function() {
  var HAPIModule, moduleKeywords,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  moduleKeywords = ['included', 'extended'];

  HAPIModule = (function() {

    function HAPIModule() {}

    HAPIModule.include = function(obj) {
      var key, value, _ref;
      if (!obj) {
        throw new Error('include(obj) requires obj');
      }
      for (key in obj) {
        value = obj[key];
        if (__indexOf.call(moduleKeywords, key) < 0) {
          this.prototype[key] = value;
        }
      }
      if ((_ref = obj.included) != null) {
        _ref.apply(this);
      }
      return this;
    };

    HAPIModule.extend = function(obj) {
      var key, value, _ref;
      if (!obj) {
        throw new Error('extend(obj) requires obj');
      }
      for (key in obj) {
        value = obj[key];
        if (__indexOf.call(moduleKeywords, key) < 0) {
          this[key] = value;
        }
      }
      if ((_ref = obj.extended) != null) {
        _ref.apply(this);
      }
      return this;
    };

    return HAPIModule;

  })();

  module.exports = HAPIModule;

}).call(this);

},{}],10:[function(require,module,exports){
// Generated by CoffeeScript 1.6.1
(function() {
  var HAPIExchangeCode;

  HAPIExchangeCode = {
    serverExchangeCode: function(code, callback) {
      var _this = this;
      return this.restClient.post("/exchangeCode", {
        code: code
      }, function(err, data) {
        if (err != null) {
          return callback(err);
        }
        return _this.completeLoginProcess(data.accessToken, data.expiresIn, callback);
      });
    }
  };

  if (typeof module !== "undefined" && module !== null) {
    module.exports = HAPIExchangeCode;
  }

}).call(this);

},{}],11:[function(require,module,exports){
// Generated by CoffeeScript 1.6.1
(function() {
  var HAPIFacebook;

  HAPIFacebook = {
    facebookLogin: function(signedRequest, callback) {
      var postData,
        _this = this;
      postData = {
        signedRequest: signedRequest,
        clientId: this.clientId
      };
      return this.restClient.post("/auth/facebook/authenticate", postData, function(err, data) {
        if (err != null) {
          return callback(err);
        }
        return _this.completeLoginProcess(data.accessToken, data.expiresIn, callback);
      });
    }
  };

  if (typeof module !== "undefined" && module !== null) {
    module.exports = HAPIFacebook;
  }

}).call(this);

},{}],12:[function(require,module,exports){
// Generated by CoffeeScript 1.6.1
(function() {
  var HAPIJQuery, HAPIRest,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  HAPIRest = require("./HAPIRest");

  HAPIJQuery = (function(_super) {

    __extends(HAPIJQuery, _super);

    function HAPIJQuery() {
      HAPIJQuery.__super__.constructor.apply(this, arguments);
      this.setCustomHeaders({
        "X-Requested-With": "XMLHttpRequest"
      });
    }

    HAPIJQuery.prototype.makeRequest = function(params, callback) {
      var req,
        _this = this;
      params.type = params.method;
      delete params.method;
      params.success = function(data, textStatus, jqXHR) {
        return callback(void 0, data);
      };
      params.error = function(jqXHR, textStatus, errorThrown) {
        var err, errors;
        errors = _this.parseErrorBody(jqXHR.responseText);
        err = new Error(errors);
        err.statusCode = jqXHR.status;
        _this.notifyError(err);
        return callback(err);
      };
      params.complete = function(jqXHR, textStatus) {
        return _this.requestManager.remove(jqXHR);
      };
      params.dataType = "json";
      req = $.ajax(params);
      if (req != null) {
        this.requestManager.add(req);
      }
      return req;
    };

    return HAPIJQuery;

  })(HAPIRest);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = HAPIJQuery;
  }

}).call(this);

},{"./HAPIRest":13}],13:[function(require,module,exports){
// Generated by CoffeeScript 1.6.1
(function() {
  var HAPIErrorParser, HAPIModule, HAPIRest, RequestManager,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  RequestManager = require("./RequestManager");

  HAPIModule = require("../objects/HAPIModule");

  HAPIErrorParser = require("./HAPIErrorParser");

  HAPIRest = (function(_super) {

    __extends(HAPIRest, _super);

    HAPIRest.include(HAPIErrorParser);

    function HAPIRest() {
      this.headers = {
        "Accept": "application/json"
      };
      this.baseUrl = "";
      this.requestManager = new RequestManager;
    }

    HAPIRest.prototype.abortAll = function() {
      return this.requestManager.abortAll();
    };

    HAPIRest.prototype.requestCount = function() {
      return this.requestManager.count();
    };

    HAPIRest.prototype.setBaseUrl = function(baseUrl) {
      this.baseUrl = baseUrl;
    };

    HAPIRest.prototype.setCustomHeaders = function(headers) {
      var key, value, _results;
      _results = [];
      for (key in headers) {
        if (!__hasProp.call(headers, key)) continue;
        value = headers[key];
        _results.push(this.headers[key] = value);
      }
      return _results;
    };

    HAPIRest.prototype.removeCustomHeader = function(header) {
      return delete this.headers[header];
    };

    HAPIRest.prototype.get = function(url, callback) {
      return this.makeRestCall({
        url: url,
        method: "GET"
      }, callback);
    };

    HAPIRest.prototype["delete"] = function(url, callback) {
      return this.makeRestCall({
        url: url,
        method: "DELETE"
      }, callback);
    };

    HAPIRest.prototype.put = function(url, data, callback) {
      return this.makeDataRequest({
        url: url,
        method: "PUT",
        data: data
      }, callback);
    };

    HAPIRest.prototype.post = function(url, data, callback) {
      return this.makeDataRequest({
        url: url,
        method: "POST",
        data: data
      }, callback);
    };

    HAPIRest.prototype.onError = function(callback) {
      var _ref;
      if ((_ref = this.globalErrorCallbacks) == null) {
        this.globalErrorCallbacks = [];
      }
      if (callback != null) {
        return this.globalErrorCallbacks.push(callback);
      }
    };

    HAPIRest.prototype.removeOnError = function(callback) {
      var backup, cb, _i, _len, _ref;
      if (callback == null) {
        return;
      }
      backup = [];
      _ref = this.globalErrorCallbacks;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        cb = _ref[_i];
        if (cb !== callback) {
          backup.push;
        }
      }
      return this.globalErrorCallbacks = backup;
    };

    HAPIRest.prototype.makeRequest = function(params, callback) {
      throw new Error("" + this.constructor.name + "::makeRequest - Override me!!");
    };

    HAPIRest.prototype.notifyError = function(err) {
      var callback, _i, _len, _ref, _results;
      if (this.globalErrorCallbacks != null) {
        _ref = this.globalErrorCallbacks;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          callback = _ref[_i];
          _results.push(callback(err));
        }
        return _results;
      }
    };

    HAPIRest.prototype.callbackValidation = function(callback) {
      if (!((callback != null) && callback instanceof Function)) {
        throw new Error("callback function not provided");
      }
    };

    HAPIRest.prototype.makeDataRequest = function(params, callback) {
      var heads, key, value, _ref;
      heads = {};
      _ref = this.headers;
      for (key in _ref) {
        if (!__hasProp.call(_ref, key)) continue;
        value = _ref[key];
        heads[key] = value;
      }
      heads["Content-Type"] = "application/json";
      params.headers = heads;
      return this.makeRestCall(params, callback);
    };

    HAPIRest.prototype.makeRestCall = function(params, callback) {
      this.callbackValidation(callback);
      if (!params.headers) {
        params.headers = this.headers;
      }
      return this.makeRequest({
        url: this.baseUrl + params.url,
        method: params.method,
        headers: params.headers,
        data: params.data != null ? JSON.stringify(params.data) : void 0
      }, callback);
    };

    return HAPIRest;

  })(HAPIModule);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = HAPIRest;
  }

}).call(this);

},{"./RequestManager":15,"../objects/HAPIModule":9,"./HAPIErrorParser":16}],14:[function(require,module,exports){
// Generated by CoffeeScript 1.6.1
(function() {
  var HAPIRest, TokenManager;

  HAPIRest = require("./HAPIRest");

  TokenManager = (function() {

    function TokenManager(restClient) {
      var _this = this;
      this.restClient = restClient;
      if (!((this.restClient != null) && this.restClient instanceof HAPIRest)) {
        this.restClient = void 0;
        throw new TypeError("You need to pass an implementation of HAPIRest");
      }
      this.restClient.onError(function(err) {
        if (err.statusCode === 401 && err.message === "accessToken is invalid. token has expired") {
          _this.removeToken();
          return typeof _this.tokenExpiredCallback === "function" ? _this.tokenExpiredCallback() : void 0;
        }
      });
    }

    TokenManager.prototype.setToken = function(token, expiresIn) {
      var _this = this;
      if (expiresIn == null) {
        throw new Error("expiresIn param required");
      }
      this.restClient.setCustomHeaders({
        Authorization: "Bearer " + token
      });
      return this.tokenExpirationTimeout = setTimeout(function() {
        _this.removeToken();
        return typeof _this.tokenExpiredCallback === "function" ? _this.tokenExpiredCallback() : void 0;
      }, expiresIn * 1000);
    };

    TokenManager.prototype.removeToken = function() {
      if (this.tokenExpirationTimeout != null) {
        clearTimeout(this.tokenExpirationTimeout);
      }
      return this.restClient.removeCustomHeader("Authorization");
    };

    TokenManager.prototype.onTokenExpired = function(tokenExpiredCallback) {
      this.tokenExpiredCallback = tokenExpiredCallback;
    };

    return TokenManager;

  })();

  if (typeof module !== "undefined" && module !== null) {
    module.exports = TokenManager;
  }

}).call(this);

},{"./HAPIRest":13}],15:[function(require,module,exports){
// Generated by CoffeeScript 1.6.1
(function() {
  var RequestManager,
    __hasProp = {}.hasOwnProperty;

  RequestManager = (function() {

    function RequestManager() {
      this.requests = {};
    }

    RequestManager.prototype.count = function() {
      var count, k, v, _ref;
      count = 0;
      _ref = this.requests;
      for (k in _ref) {
        if (!__hasProp.call(_ref, k)) continue;
        v = _ref[k];
        count++;
      }
      return count;
    };

    RequestManager.prototype.add = function(req) {
      if (req == null) {
        throw new Error(this.constructor.Name + "::add -  Not a valid request");
      }
      if ((req.requestId != null) && (this.requests[req.requestId] != null)) {
        return;
      }
      req.requestId = (Math.random()).toString(36).slice(2);
      return this.requests[req.requestId] = req;
    };

    RequestManager.prototype.remove = function(req) {
      if (req == null) {
        return;
      }
      return delete this.requests[req.requestId];
    };

    RequestManager.prototype.abortAll = function() {
      var k, v, _ref, _results;
      _ref = this.requests;
      _results = [];
      for (k in _ref) {
        if (!__hasProp.call(_ref, k)) continue;
        v = _ref[k];
        v.abort();
        _results.push(this.remove(v));
      }
      return _results;
    };

    return RequestManager;

  })();

  if (typeof module !== "undefined" && module !== null) {
    module.exports = RequestManager;
  }

}).call(this);

},{}],16:[function(require,module,exports){
// Generated by CoffeeScript 1.6.1
(function() {
  var HAPIErrorParser;

  HAPIErrorParser = {
    parseErrorBody: function(responseBody) {
      var errors;
      errors = "";
      try {
        errors = JSON.parse(responseBody);
        errors = errors.errors.join("\n");
      } catch (e) {
        errors = responseBody;
      }
      return errors;
    }
  };

  module.exports = HAPIErrorParser;

}).call(this);

},{}]},{},[1])
;